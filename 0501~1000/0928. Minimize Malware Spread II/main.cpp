/**
 * Source: t.ly/6DBkB
 * Date: 2023/11/3
 * Skill:
 * Runtime: 84 ms, faster than 88.09% of C++ online submissions
 * Memory Usage: 43.74 MB, less than 48.51% of C++ online submissions
 * Time complexity: O(n)
 * Space complexity: O(n)
 * Constraints:
 *
 */


const int MX = 301;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        vector<int> adj_list[MX];
        int n = graph.size(), infect[MX] = {0}, visited[MX] = {0};
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    adj_list[i].push_back(j);
                    adj_list[j].push_back(i);
                }
            }
        }
        for (auto i: initial) infect[i] = 1;
        int chosen, res, mx = n;
        function<int(int cur)> dfs;
        dfs = [&](int cur) {
            int num = 1;
            for (auto i: adj_list[cur]) {
                if (visited[i] == 1 || i == chosen) continue;
                visited[i] = 1;
                num += dfs(i);
            }
            return num;
        };

        for (auto i: initial) {
            chosen = i;
            int num = 0;
            for (int j = 0; j < n; j++) visited[j] = 0;
            for (int j = 0; j < n; j++) {
                if (j == i || visited[j] == 1 || infect[j] == 0) continue;
                visited[j] = 1;
                num += dfs(j);
            }
            if (num < mx) {
                mx = num;
                res = i;
            } else if (num == mx) {
                res = min(res, i);
            }
        }
        return res;
    }
};


int main() {
    Solution s;
    vector<vector<int>> arr{{1,1,0}, {1,1,1},{0,1,1}};
    vector<int> nums{0, 1};
    int res = s.minMalwareSpread(arr, nums);
}